## Querydsl Select에 대하여

## 1. 개요

조회에 관하여 Entity를 직접 조회 하게 되면 성능에 대한 문제가 발생할 여지가 많다.

예를 들면 영속성 컨택스트의 1차 캐시 기능을 사용하게 되기도 하고 불필요한 칼럼을 조회하기도 한다.

따라서 Entity를 직접 조회하는것보다 Dto혹은 Vo를 조회하는것이 좋다.

Querydsl에서의 Dto를 조회 하는 법에 대하여 알아보자.



## 2. 사용 해야 하는 이유

개요에서 예를 들었던 내용이다.

조금더 자세하게 알아보자

- 필요한 데이터만 선택

엔티티는 보통 많은 필드를 가지고 있습니다. 하지만 특정 조회 작업에서는 필요한 필드만 선택하여 가져오는 것이 효율적일 수 있다. DTO를 사용하면 필요한 필드만을 선택하여 데이터베이스에서 가져올 수 있다. 이는 불필요한 데이터를 조회하지 않고 필요한 데이터만을 전송하여 네트워크 부하를 줄일 수 있다.

- 레이어 간 의존성 분리

DTO를 사용하면 엔티티와 데이터 전송을 위한 객체 사이의 의존성을 분리할 수 있다. 엔티티는 주로 데이터베이스와의 상호작용을 담당하고, DTO는 비즈니스 로직이나 API 응답과 같은 다른 목적을 위한 데이터 전송을 담당한다. 이렇게 의존성을 분리하면 엔티티의 변경이 DTO에 영향을 미치지 않고, 시스템의 유연성과 확장성을 향상시킬 수 있다.

- 데이터 가공과 표현 변환

DTO를 사용하면 엔티티로부터 데이터를 가공하거나 필요에 따라 표현을 변환할 수 있다. 예를 들어, 날짜 형식을 변경하거나, 엔티티 간의 관계를 표현하기 위해 중첩된 구조로 변환할 수 있다. 이는 클라이언트에게 더욱 적합한 형태로 데이터를 전달할 수 있다.

- 쿼리 성능 최적화

  1. 필요한 데이터만 선택

     엔티티는 보통 많은 필드를 가지고 있습니다. 하지만 특정 조회 작업에서는 필요한 필드만 선택하여 가져오는 것이 효율적일 수 있다. DTO를 사용하면 필요한 필드만을 선택하여 데이터베이스에서 가져올 수 있다. 이는 불필요한 데이터를 조회하지 않고 필요한 데이터만을 전송하여 네트워크 부하를 줄일 수 있다.

  2. 레이어 간 의존성 분리

     DTO를 사용하면 엔티티와 데이터 전송을 위한 객체 사이의 의존성을 분리할 수 있다. 엔티티는 주로 데이터베이스와의 상호작용을 담당하고, DTO는 비즈니스 로직이나 API 응답과 같은 다른 목적을 위한 데이터 전송을 담당한다. 이렇게 의존성을 분리하면 엔티티의 변경이 DTO에 영향을 미치지 않고, 시스템의 유연성과 확장성을 향상시킬 수 있다.

  3. 데이터 가공과 표현 변환

     DTO를 사용하면 엔티티로부터 데이터를 가공하거나 필요에 따라 표현을 변환할 수 있다. 예를 들어, 날짜 형식을 변경하거나, 엔티티 간의 관계를 표현하기 위해 중첩된 구조로 변환할 수 있다. 이는 클라이언트에게 더욱 적합한 형태로 데이터를 전달할 수 있다.

  4. 쿼리 성능 최적화

     DTO를 사용하여 필요한 필드만 조회하고, 필요 없는 필드는 제외하면 데이터베이스의 부하를 줄일 수 있다. 불필요한 조인이나 데이터 로딩을 피할 수 있으며, 결과적으로 쿼리의 성능을 최적화할 수 있다.

     

- 보안

엔티티는 애플리케이션의 내부 도메인 개념을 반영하는 경우가 많다. 따라서 외부로 노출되면 보안상의 위험이 발생할 수 있다. DTO를 사용하여 필요한 데이터만을 전달하면, 민감한 정보를 외부로 노출하지 않을 수 있다.



**당연히 쓰지 아니할 이유가 없다.** 😄



## 3. 사용법

사용 할 수 있는 방법들은 아주 많다.

1. Projections를 이용한 DTO 조회
2. Bean 타입 매핑
3. QBean 타입 매핑
4. 생성자를 직접 호출하여 매핑
5. Tuple로 조회 후 매핑
6. Map으로 직접 매핑
7. QueryProjection 어노테이션 사용
8. Interface 기반 Projection
9. MapStruct 사용
10. ResultTransformer 사용
11. JdbcTemplate 사용
12. Dozer, ModelMapper 등의 매핑 라이브러리 사용

이중에서 내가 생각하기에 가장 유용한 방법인 1번과 7번에 대해 설명한다.

### 3.1 Projections

해당 기능을 사용하는 방법 또한 여러가지가 있다.

1. Projections.constructor():
   - `Projections.constructor()` 메서드를 사용하여 DTO의 생성자를 호출하여 매핑한다.
   - 장점:
     - DTO 클래스의 생성자를 활용하므로 코드가 간결진다.
     - 런타임 시에 필드의 일치 여부를 확인할 수 있다. (**이 부분은 개인적으로 단점이라 생각한다**)
   - 단점:
     - 필드 순서와 타입이 일치해야 하므로 유연성이 제한된다.
     - 필드의 개수가 많을 경우 생성자의 매개변수가 많아지는 문제가 발생할 수 있다.
2. Projections.fields():
   - `Projections.fields()` 메서드를 사용하여 DTO의 필드와 엔티티의 필드를 직접 지정하여 매핑한다.
   - 장점:
     - DTO의 필드와 엔티티의 필드를 자유롭게 선택할 수 있다.
     - 필드 순서와 타입에 제약이 없다.
   - 단점:
     - DTO 필드와 엔티티 필드의 이름이 일치해야 하므로 유의해야 한다.
3. Projections.bean():
   - `Projections.bean()` 메서드를 사용하여 DTO와 엔티티를 매핑하는데, DTO 클래스와 엔티티 클래스의 필드명이 일치해야 한다.
   - 장점:
     - DTO 클래스와 엔티티 클래스의 필드명을 일치시키는 작업만으로 매핑이 가능하다.
   - 단점:
     - 필드명을 일치시키기 위한 작업이 필요하며, 이는 유지보수 측면에서 주의가 필요하다.
4. Projections.constructorArgs():
   - `Projections.constructorArgs()` 메서드를 사용하여 DTO의 생성자에 인자 값을 지정하여 매핑한다.
   - 장점:
     - DTO 클래스의 생성자에 직접 인자 값을 전달하므로, 생성자의 시그니처에 더 유연성을 가질 수 있다.
   - 단점:
     - 생성자의 시그니처를 정확하게 지정해야 하므로, 실수할 여지가 있다.



설명한 모든 방법들의 치명적인 단점이 있다.

모두 컴파일 단계에서는 잘못된 점을 체크 할 수 가 없다.

따라서 가장 권장하는 방식은 아래 설명하는 방식이다.

### 3.2 QueryProjection 어노테이션

간단하게 생성자 위에 `@QueryProjection` 어노테이션을 추가하면 된다.

```java
public class ProductDto {
    private Long id;
    private String name;
    private BigDecimal price;

    @QueryProjection
    public ProductDto(Long id, String name, BigDecimal price) {
        this.id = id;
        this.name = name;
        this.price = price;
    }
}
```

그리고 조회

```java
List<ProductDto> products = queryFactory
    .select(new QProductDto(product.id, product.name, product.price))
    .from(product)
    .fetch();
```

QueryProjection 어노테이션은 Querydsl 라이브러리에서 제공하는 기능으로, 생성자에 어노테이션을 붙여 DTO 클래스를 매핑하는 방법이다.

장점

- **컴파일 시점에서 필드의 일치 여부를 확인할 수 있다.**
- 코드가 간결해지고 가독성이 좋아진다.
- IDE에서 자동 완성 및 리팩토링 기능을 지원한다.

단점:

- DTO 클래스에 Querydsl의 의존성이 추가된다.
- DTO 클래스에 Querydsl 어노테이션을 사용하므로, DTO 클래스가 Querydsl에 의존성을 가지게 되어 DTO 클래스의 재사용성이 떨어질 수 있다.
- DTO 클래스와 엔티티 클래스의 필드명이 일치해야 하므로, 필드명 변경 시에는 수정해야 한다.

가장 막강한 강점은 **컴파일 시점에서 필드의 일치 여부를 확인**할 수 있다 라는 점이다.

가장 좋은 에러는 컴파일 시점에서 나타나는 에러라고 생각하며, 다른 단점들을 다 커버 할 수 있는 점이라 생각한다.



## 4. 결론

각 방법은 사용하는 DTO 클래스와 엔티티 클래스의 구조, 필요한 필드의 선택 등에 따라 선택할 수 있고, 

프로젝트의 요구사항과 개발 스타일에 따라 적절한 방법을 선택하여 사용하면 된다.

하지만 의존관계도 중요하지만 컴파일 시점에 알 수 있는 QueryProjection을 나는 선호 한다.
